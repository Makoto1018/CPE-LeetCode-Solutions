## Problem Title

- **Problem Number**:  15. 3Sum
- **Difficulty**: Medium
- **Link**: [LeetCode 問題連結](https://leetcode.com/problems/3sum/description/?difficulty=EASY&page=1)
- **是否有先參考別人的觀念**: 有
1. 雙指針法 [解法連結](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.md)
---

### Problem Description

Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

---

### Approach

1. **思路概述**：
    - 對於每一個數字 nums[i]，我們可以使用雙指針法來尋找另外兩個數字 nums[left] 和 nums[right]，使得 nums[i] + nums[left] + nums[right] = 0。
    - 會先排序 nums ，用 i 來找到第一個數字，然後用 left 跟 right 來尋找另外兩個數字。
    - 當 nums[i] > 0 時，則不可能有三個數字的和為 0，因此可以直接返回結果。
    - 當 i>0 && nums[i] == nums[i-1] 時，則跳過這個數字，避免重複計算。

2. **關鍵步驟**：
3. **時間複雜度分析**：$O(n^2)$  
---

### Other Solution

> 其他的解法

---
### Summary

- **學到的新觀念**: 
    - 雙指針法的應用
    - 如何避免重複計算
- **遇到的困難點與解法**:
    - 在使用雙指針法時，如何正確地移動指針以避免重複計算
    - 如何處理邊界情況，例如當 nums[i] > 0 時，直接返回結果
    - 三個數字都一樣的時候要記得用額外的迴圈整理掉
---

### code
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(),nums.end());

        for(int i=0;i<nums.size();i++){
            if (nums[i] > 0) {
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            int left=i+1;
            int right=nums.size()-1;
            while(right>left){
                if(nums[i]+nums[left]+nums[right]<0){
                    left++;
                }
                else if(nums[i]+nums[left]+nums[right]>0){
                    right--;
                }
                else{
                    res.push_back(vector<int>{nums[i],nums[left],nums[right]});
                    while(right>left&&nums[right]==nums[right-1]){
                        right--;
                    }
                    while(right>left&&nums[left]==nums[left+1]){
                        left++;
                    }
                    left++;
                    right--;
                }
            }
        }
        return res;
    }
};

```