## Problem Title

- **Problem Number**:  18. 4Sum
- **Difficulty**: Medium
- **Link**: [LeetCode 問題連結](https://leetcode.com/problems/4sum/description/?difficulty=EASY&page=1)
- **是否有先參考別人的觀念**: 有
1. 雙指針法 + 去重 [解法連結](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.md)
---

### Problem Description

Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:

0 <= a, b, c, d < n
a, b, c, and d are distinct.
nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.

---

### Approach

1. **思路概述**：
    - 跟 3Sum 很像，多一層迴圈來考慮 i 跟 k 的情況
    - 先將 nums 排序
    - 使用雙指針法來找到四個數字的和等於目標值
    - 使用額外的迴圈來避免重複計算
    - 注意邊界情況，例如當 nums[i] > target 時，直接返回結果
2. **關鍵步驟**：
3. **時間複雜度分析**：$O(n^3)$  
---

### Other Solution

> 其他的解法

---
### Summary

- **學到的新觀念**: 
    - 雙指針法的應用
    - 如何避免重複計算
    - 邊界情況的處理
- **遇到的困難點與解法**:
    - 在處理重複數字時，如何有效地跳過重複的數字
    - 邊界情況的處理，例如當 nums[i] > target 時，直接返回結果
---

### code
```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++){
            if(nums[i]>target && nums[i]>=0){
                break;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            for(int k=i+1;k<nums.size();k++){
                if(nums[i] + nums[k]>target && nums[i] + nums[k]>=0){
                    break;
                }
                if(k>i+1&&nums[k]==nums[k-1]){
                    continue;
                }
                int left = k+1;
                int right = nums.size()-1;
                while(right > left){
                    if((long)nums[i]+nums[k]+nums[left]+nums[right]>target){
                        right--;
                    }
                    else if((long)nums[i]+nums[k]+nums[left]+nums[right]<target){
                        left++;
                    }
                    else{
                        res.push_back(vector<int>{nums[i],nums[k],nums[left],nums[right]});
                        while(right > left && nums[right]==nums[right-1]){
                            right--;
                        }
                        while(right > left && nums[left]==nums[left+1]){
                            left++;
                        }
                        right--;
                        left++;
                    }
                }
            }
        }
        return res;
    }
};
```