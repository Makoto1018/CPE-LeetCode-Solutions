## Problem Title

- **Problem Number**:  209. Minimum Size Subarray Sum
- **Difficulty**: Medium
- **Link**: [LeetCode 問題連結](https://leetcode.com/problems/minimum-size-subarray-sum/description/)
- **是否有先參考別人的觀念**: 有，滑動窗口
---

### Problem Description

Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.
---

### Approach

1. **思路概述**：滑動窗口
2. **關鍵步驟**：擴張窗口，透過 fast 向右移動來累加總和。 縮小窗口：當總和大於等於 target 時，移動 slow 來找最短長度
3. **時間複雜度分析**：$O(n)$  

### Summary

- **學到的新觀念** 
1. 滑動窗口
- **遇到的困難點與解法**  
1. 掌握快慢指標的移動邏輯與邊界條件處理
### code

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int fast=0, slow=0;
        int res=100001;
        int total=0;
        bool need_add=true;
        while(fast<nums.size()&&slow<nums.size()){
            if(need_add)
                total += nums[fast];
            if(total>=target){
                if(fast-slow+1<res){
                    res = fast-slow+1;
                }
                total -= nums[slow];
                need_add = false;
                slow++;
            }
            else{
                fast++;
                need_add = true;   
            }
        }
        if(res==100001)
            return 0;
        else
            return res;
    }
};
```